---
title: JavaScript之垃圾回收
tags: JavaScript
categories:
  - JavaScript基础
cover: garbageCollection.jpg
abbrlink: 7f9dff54
date: 2021-02-03 17:46:45
---

#### 内存声明周期

不管什么程序语言，内存生命周期基本是一致的：

1. 分配你所需要的内存
2. 使用分配到的内存（读、写）
3. 不需要时将其释放/归还

<!-- more -->

#### 当内存不再需要使用时释放

大多数内存管理的问题都在这个阶段。在这里最艰难的任务就是找到“哪些被分配的内存确实已经不再需要了“。

高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当跟踪的内存不在使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是**无法判定的**（无法通过某种算法解决）。



#### 垃圾回收

垃圾回收只能**有限制**的解决一般问题。下面是主要的垃圾回收算法和局限性。



##### 引用

在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或显式），叫做一个对象引用另一个对象。例如，一个对象具有对它原型的引用（隐式引用）和对它属性的引用（显示引用）。**垃圾回收算法主要依赖于引用的概念**。



##### 1. 引用计数垃圾收集

​	此算法把“对象是否不在需要“简化定义为“对象有没有其他对象引用到它“。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。



###### 限制：循环引用

该算法有个限制：无法处理循环引用的实例。

```javascript
function f(){
  var o={};
  var o2={};
  o.a=o2;  // o 引用了o2
  o2.a=o;	 // o2引用了o
  
  return 'azerty';
}

f();
```





##### 2. 标记-清除算法

​	此算法把“对象是否不在需要”简化定义为“对象是否可以获得“。

​	这个算法假定设置一个叫做根（root）的对象（在JavaScript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象......从根开始，**垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象**。

​	这个算法比前一个要好，因为“有零引用的对象“总是不可获得的，但是相反却不一定。从上面的例子中，函数调用返回后，两个对象从全局对象出发无法获取。因此，它们将会被垃圾回收器回收。因此，**循环引用不再是问题了。**

​	从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进。

